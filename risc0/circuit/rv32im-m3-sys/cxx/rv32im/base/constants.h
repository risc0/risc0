// Copyright 2025 RISC Zero, Inc.
//
// Licensed under the Apache License, Version 2.0, <LICENSE-APACHE or
// http://apache.org/licenses/LICENSE-2.0> or the MIT license <LICENSE-MIT or
// http://opensource.org/licenses/MIT>, at your option. This file may not be
// copied, modified, or distributed except according to those terms.
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: Apache-2.0 OR MIT

#pragma once

#if !defined(METAL)
#include <cstdint>
#endif

#ifndef CONSTANT
#define CONSTANT constexpr
#endif

// Very basic numbers
CONSTANT uint32_t BITS_PER_BYTE = 8;
CONSTANT uint32_t BYTES_PER_WORD_PO2 = 2;
CONSTANT uint32_t BYTES_PER_WORD = (1 << BYTES_PER_WORD_PO2);

// Physical Merkle Paging constants
CONSTANT uint32_t MPAGE_SIZE_BYTES_PO2 = 10;
CONSTANT uint64_t MPAGE_SIZE_BYTES = 1 << MPAGE_SIZE_BYTES_PO2;
CONSTANT uint64_t MPAGE_MASK_BYTES = (MPAGE_SIZE_BYTES - 1);
CONSTANT uint32_t MPAGE_SIZE_WORDS_PO2 = MPAGE_SIZE_BYTES_PO2 - BYTES_PER_WORD_PO2;
CONSTANT uint64_t MPAGE_SIZE_WORDS = MPAGE_SIZE_BYTES / BYTES_PER_WORD;
CONSTANT uint64_t MPAGE_MASK_WORDS = (MPAGE_SIZE_WORDS - 1);

// Logical MMU Paging constants
CONSTANT uint32_t VPAGE_SIZE_BYTES_PO2 = 12;
CONSTANT uint64_t VPAGE_SIZE_BYTES = 1 << VPAGE_SIZE_BYTES_PO2;
CONSTANT uint64_t VPAGE_MASK_BYTES = (VPAGE_SIZE_BYTES - 1);
CONSTANT uint32_t VPAGE_SIZE_WORDS_PO2 = VPAGE_SIZE_BYTES_PO2 - BYTES_PER_WORD_PO2;
CONSTANT uint64_t VPAGE_SIZE_WORDS = VPAGE_SIZE_BYTES / BYTES_PER_WORD;
CONSTANT uint64_t VPAGE_MASK_WORDS = (VPAGE_SIZE_WORDS - 1);

// Size of total memory
CONSTANT uint64_t MEMORY_SIZE_BYTES = uint64_t(1) << 32;
CONSTANT uint64_t MEMORY_SIZE_WORDS = MEMORY_SIZE_BYTES / BYTES_PER_WORD;
CONSTANT uint64_t MEMORY_SIZE_MPAGES = MEMORY_SIZE_BYTES / MPAGE_SIZE_BYTES;

// Mode constants
CONSTANT uint32_t MODE_USER = 0;
CONSTANT uint32_t MODE_SUPERVISOR = 1;
CONSTANT uint32_t MODE_MACHINE = 3;

// Access constants
CONSTANT uint32_t ACCESS_FETCH = 0;
CONSTANT uint32_t ACCESS_LOAD = 1;
CONSTANT uint32_t ACCESS_STORE = 2;

// Trap cause constants
CONSTANT uint32_t MCAUSE_NONE = 32;
CONSTANT uint32_t MCAUSE_INSTRUCTION_ACCESS_FAULT = 1;
CONSTANT uint32_t MCAUSE_ILLEGAL_INSTRUCTION = 2;
CONSTANT uint32_t MCAUSE_LOAD_ADDRESS_MISALIGNED = 4;
CONSTANT uint32_t MCAUSE_LOAD_ACCESS_FAULT = 5;
CONSTANT uint32_t MCAUSE_STORE_ADDRESS_MISALIGNED = 6;
CONSTANT uint32_t MCAUSE_STORE_ACCESS_FAULT = 7;
CONSTANT uint32_t MCAUSE_ECALL_FROM_UMODE = 8;
CONSTANT uint32_t MCAUSE_ECALL_FROM_SMODE = 9;
CONSTANT uint32_t MCAUSE_INSTRUCTION_PAGE_FAULT = 12;
CONSTANT uint32_t MCAUSE_LOAD_PAGE_FAULT = 13;
CONSTANT uint32_t MCAUSE_STORE_PAGE_FAULT = 15;
CONSTANT uint32_t MCAUSE_TIMER_INTERRUPT = 0x80000005;

// Memory address ranges (really only used for ELF loading?)
CONSTANT uint32_t USER_START_ADDR = 0;
CONSTANT uint32_t USER_START_WORD = USER_START_ADDR / BYTES_PER_WORD;
CONSTANT uint32_t USER_END_ADDR = 0xc0000000;
CONSTANT uint32_t USER_END_WORD = USER_END_ADDR / BYTES_PER_WORD;
CONSTANT uint32_t KERNEL_START_ADDR = 0xc0000000;
CONSTANT uint32_t KERNEL_START_WORD = KERNEL_START_ADDR / BYTES_PER_WORD;
CONSTANT uint32_t KERNEL_END_ADDR = 0xff000000;
CONSTANT uint32_t KERNEL_END_WORD = KERNEL_END_ADDR / BYTES_PER_WORD;

// Various memory mapped things
CONSTANT uint32_t MACHINE_REGS_ADDR = 0xffff0000;
CONSTANT uint32_t MACHINE_REGS_WORD = MACHINE_REGS_ADDR / BYTES_PER_WORD;
CONSTANT uint32_t USER_REGS_ADDR = 0xffff0080;
CONSTANT uint32_t USER_REGS_WORD = USER_REGS_ADDR / BYTES_PER_WORD;
CONSTANT uint32_t CSR_BASE_ADDR = 0xffff4000;
CONSTANT uint32_t CSR_BASE_WORD = CSR_BASE_ADDR / BYTES_PER_WORD;
CONSTANT uint32_t COMPRESSED_INST_LOOKUP_ADDR = 0xfff80000;
CONSTANT uint32_t COMPRESSED_INST_LOOKUP_WORD = COMPRESSED_INST_LOOKUP_ADDR / BYTES_PER_WORD;

// Macro to get CSR as a word address
#define CSR_ADDR(name) (CSR_BASE_ADDR + BYTES_PER_WORD * CSR_##name)
#define CSR_WORD(name) (CSR_BASE_WORD + CSR_##name)

// User mode CSRs
CONSTANT uint32_t CSR_CYCLE = 0xc00;
CONSTANT uint32_t CSR_TIME = 0xc01;
CONSTANT uint32_t CSR_INSTRET = 0xc02;
CONSTANT uint32_t CSR_CYCLEH = 0xc80;
CONSTANT uint32_t CSR_TIMEH = 0xc81;
CONSTANT uint32_t CSR_INSTRETH = 0xc82;

// Required supervisory CSRs
CONSTANT uint32_t CSR_SSTATUS = 0x100;
CONSTANT uint32_t CSR_SIE = 0x104;
CONSTANT uint32_t CSR_STVEC = 0x105;
CONSTANT uint32_t CSR_SCOUNTEREN = 0x106;
CONSTANT uint32_t CSR_SENVCFG = 0x10a;
CONSTANT uint32_t CSR_SSCRATCH = 0x140;
CONSTANT uint32_t CSR_SEPC = 0x141;
CONSTANT uint32_t CSR_SCAUSE = 0x142;
CONSTANT uint32_t CSR_STVAL = 0x143;
CONSTANT uint32_t CSR_SIP = 0x144;
CONSTANT uint32_t CSR_SATP = 0x180;

// Standard machine CSRs we actually use
CONSTANT uint32_t CSR_MTVEC = 0x305;
CONSTANT uint32_t CSR_MEPC = 0x341;
CONSTANT uint32_t CSR_MCAUSE = 0x342;
CONSTANT uint32_t CSR_MTVAL = 0x343;

// Custom machine CSRs
CONSTANT uint32_t CSR_MSPC = 0x7C0;
CONSTANT uint32_t CSR_MSMODE = 0x7C1;
CONSTANT uint32_t CSR_MVINFO = 0x7C2;
CONSTANT uint32_t CSR_MNOPTE1 = 0x7C3;
CONSTANT uint32_t CSR_MNOPTE2 = 0x7C4;

// Nice names for registers
CONSTANT uint32_t REG_ZERO = 0;
CONSTANT uint32_t REG_RA = 1;
CONSTANT uint32_t REG_SP = 2;
CONSTANT uint32_t REG_GP = 3;
CONSTANT uint32_t REG_TP = 4;
CONSTANT uint32_t REG_T0 = 5;
CONSTANT uint32_t REG_T1 = 6;
CONSTANT uint32_t REG_T2 = 7;
CONSTANT uint32_t REG_S0 = 8;
CONSTANT uint32_t REG_FP = 8;
CONSTANT uint32_t REG_S1 = 9;
CONSTANT uint32_t REG_A0 = 10;
CONSTANT uint32_t REG_A1 = 11;
CONSTANT uint32_t REG_A2 = 12;
CONSTANT uint32_t REG_A3 = 13;
CONSTANT uint32_t REG_A4 = 14;
CONSTANT uint32_t REG_A5 = 15;
CONSTANT uint32_t REG_A6 = 16;
CONSTANT uint32_t REG_A7 = 17;
CONSTANT uint32_t REG_S2 = 18;
CONSTANT uint32_t REG_S3 = 19;
CONSTANT uint32_t REG_S4 = 20;
CONSTANT uint32_t REG_S5 = 21;
CONSTANT uint32_t REG_S6 = 22;
CONSTANT uint32_t REG_S7 = 23;
CONSTANT uint32_t REG_S8 = 24;
CONSTANT uint32_t REG_S9 = 25;
CONSTANT uint32_t REG_S10 = 26;
CONSTANT uint32_t REG_S11 = 27;
CONSTANT uint32_t REG_T3 = 28;
CONSTANT uint32_t REG_T4 = 29;
CONSTANT uint32_t REG_T5 = 30;
CONSTANT uint32_t REG_T6 = 31;

// Machine mode ecalls
CONSTANT uint32_t HOST_ECALL_TERMINATE = 0;
CONSTANT uint32_t HOST_ECALL_READ = 1;
CONSTANT uint32_t HOST_ECALL_WRITE = 2;
CONSTANT uint32_t HOST_ECALL_POSEIDON2 = 3;
CONSTANT uint32_t HOST_ECALL_SHA2 = 4;
CONSTANT uint32_t HOST_ECALL_BIGINT = 5;

// Poseidon flags
CONSTANT uint32_t PFLAG_IS_ELEM = 0x80000000;
CONSTANT uint32_t PFLAG_CHECK_OUT = 0x40000000;

// Circuit constants
CONSTANT uint32_t ACCUM_MIX_SIZE = 50;
CONSTANT uint32_t ACCUM_BIGINT_Z = 49;
CONSTANT uint32_t MAX_ACCUM_PER_ROW = 148;
