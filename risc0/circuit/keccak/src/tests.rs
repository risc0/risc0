// Copyright 2024 RISC Zero, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use crate::prove::{prove, verify};
use anyhow::Result;
use hex::FromHex;
use risc0_binfmt::read_sha_halfs;
use risc0_circuit_keccak_test_methods::{KECCAK_ELF, KECCAK_ID};
use risc0_core::field::baby_bear::BabyBearElem;
use risc0_zkp::{
    core::{
        digest::{Digest, DIGEST_SHORTS},
        hash::poseidon2::Poseidon2HashSuite,
    },
    hal::cpu::CpuHal,
};
use risc0_zkvm::{
    get_prover_server, ExecutorEnv, KeccakCoprocessorCallback, ProveKeccakRequest,
    ProveKeccakResponse, ProveZkrRequest, ProverOpts,
};
use std::{cell::RefCell, collections::VecDeque, rc::Rc};

struct Coprocessor;

impl Coprocessor {
    fn new() -> Self {
        Self
    }
}

impl KeccakCoprocessorCallback for Coprocessor {
    fn prove_keccak(&mut self, req: ProveKeccakRequest) -> Result<ProveKeccakResponse> {
        let hash_suite = Poseidon2HashSuite::new_suite();
        let hal = CpuHal::new(hash_suite.clone());
        let input_u32s: &[u32] = bytemuck::cast_slice(req.input.as_slice());
        let input: VecDeque<u32> = Vec::from(input_u32s).into();
        let circuit_hal = crate::prove::cpu::CpuCircuitHal::new(input);
        let control_root: Digest = *crate::get_control_root(req.po2);
        let seal = prove(&hal, &circuit_hal, req.po2).unwrap();
        let claim_digest: Digest = read_sha_halfs(&mut VecDeque::from_iter(
            bytemuck::checked::cast_slice::<_, BabyBearElem>(&seal[0..DIGEST_SHORTS])
                .iter()
                .copied()
                .map(u32::from),
        ))?;

        // Make sure we have a valid seal so we can fail early if anything went wrong
        verify(seal.as_slice(), &hash_suite).expect("Verification failed");

        let claim_sha_input = claim_digest
            .as_words()
            .iter()
            .copied()
            .flat_map(|x| [x & 0xffff, x >> 16])
            .map(BabyBearElem::new)
            .collect::<Vec<_>>();

        let mut zkr_input: Vec<u32> = Vec::new();
        zkr_input.extend(control_root.as_words());
        zkr_input.extend(seal);
        zkr_input.extend(bytemuck::cast_slice(claim_sha_input.as_slice()));

        // Lift to recursion circuit
        let zkr_lift = ProveZkrRequest {
            control_id: *crate::get_control_id(req.po2),
            claim_digest,
            input: bytemuck::cast_slice(zkr_input.as_slice()).into(),
        };

        Ok(ProveKeccakResponse { zkr_lift })
    }
}

fn from_hex(input: &str) -> Vec<u32> {
    let u8s: Vec<u8> = (0..input.len())
        .step_by(2)
        .map(|idx| u8::from_str_radix(&input[idx..idx + 2], 16).unwrap())
        .collect();
    assert!(u8s.len() % 4 == 0);
    u8s.chunks(4)
        .map(|slice| u32::from_le_bytes(slice.try_into().unwrap()))
        .collect()
}

fn run_test(claim_digest: Digest, input: Vec<u32>, po2: usize) -> Result<()> {
    let to_guest: (Digest, Vec<u32>, usize) = (claim_digest, input, po2);

    let coprocessor = Rc::new(RefCell::new(Coprocessor::new()));

    let env = ExecutorEnv::builder()
        .keccak_coprocessor_callback_ref(coprocessor.clone())
        .write(&to_guest)?
        .build()?;

    crate::prove::zkr::register_zkrs();

    let prover = get_prover_server(&ProverOpts::fast())?;

    // Produce a receipt by proving the specified ELF binary.
    let receipt = prover.prove(env, KECCAK_ELF)?.receipt;

    // Make sure this receipt actually depends on the assumption;
    // otherwise this test might give a false negative.
    assert!(!receipt
        .inner
        .composite()
        .unwrap()
        .assumption_receipts
        .is_empty());

    // Make sure the receipt verifies OK
    receipt.verify(KECCAK_ID)?;

    Ok(())
}

#[test]
fn test_keccak_0() -> Result<()> {
    run_test(
        /*claim=*/
        Digest::from_hex("c376d218a46f1750d1630ea2f9dc0b7ac1cae1a60a6a259b10237c1aa86332a8")?,
        from_hex(
"010000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000080c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a4700000000000000000",
        ),
        /*po2=*/ 14,
    )?;
    Ok(())
}

#[test]
fn test_keccak_0s() -> Result<()> {
    run_test(
        /*claim=*/
        Digest::from_hex("d7da872c192171744dcf92daa191f6534c9f10be0ac87e90f3166b7597c5cca0")?,
        from_hex(
"010000000000000006000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000080a7ffc6f8bf1ed76651c14756a061d662f580ff4de43b49fa82d80a4b80f8434a0000000000000000",
        ),
        /*po2=*/ 14,
    )?;
    Ok(())
}

#[test]
fn test_keccak_1k() -> Result<()> {
    run_test(
        /*claim=*/
        Digest::from_hex("95b36374988e6e0aec7cb31754fd4847b0099392dafc47593f5778668a26c723")?,
        from_hex(
            "010000000000000054686520717569636B2062726F776E20666F78206A756D7073206F76657220746865206C617A7920646F672E0100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000080578951e24efd62a3d63a86f7cd19aaa53c898fe287d2552133220370240b572d0000000000000000",
        ),
        /*po2=*/ 14,
    )?;
    Ok(())
}

#[test]
fn test_keccak_1s() -> Result<()> {
    run_test(
        /*claim=*/
// CHECK: sha256output: 0x56e6,0xb26d 0x9be,0x1343 0xb698,0xebe5 0x4dd,0xb185 0x60dd,0x3168 0x8a01,0x1555 0x3bab,0xfdff 0xf3a2,0xe0db
        Digest::from_hex("e6566db2be09431398b6e5ebdd0485b1dd606831018a5515ab3bfffda2f3dbe0")?,
        from_hex(
"010000000000000054686520717569636B2062726F776E20666F78206A756D7073206F76657220746865206C617A7920646F672E0600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000080a80f839cd4f83f6c3dafc87feae470045e4eb0d366397d5c6ce34ba1739f734d0000000000000000",
        ),
        /*po2=*/ 14,
    )?;
    Ok(())
}

#[test]
fn test_keccak_2k() -> Result<()> {
    run_test(
        /*claim=*/
        Digest::from_hex("0e422c6bcdc46e396bcf4c7e4c8b1e1cc3889558b534fd813713a69330e5f106")?,
        from_hex(
"0600000000000000436F6D6D616E64657220526F64657269636B20426C61696E65206C6F6F6B6564206672616E746963616C6C792061726F756E6420746865206272696467652E20776865726520686973206F66666963657273207765726520646972656374696E6720726570616972732077697468206C6F7720616E6420757267656E7420766F696365732C2073757267656F6E7320617373697374696E67206174206120646966666963756C74206F7065726174696F6E2E20546865206772617920737465656C20636F6D706172746D656E7420776173206120636F6E667573696F6E206F6620616374697669746965732C2065616368206F726465726C7920627920697473656C662062757420746865206F766572616C6C20696D7072657373696F6E20776173206F66206368616F732E2053637265656E732061626F7665206F6E652068656C6D736D616E27732073746174696F6E2073686F7765642074686520706C616E65742062656C6F7720616E6420746865206F746865722C20736869707320696E206F72626974206E656172204D61634172746875722C20627574206576657279776865726520656C7365207468652070616E656C20636F7665727320686164206265656E2072656D6F7665642066726F6D20636F6E736F6C65732C207465737420696E737472756D656E7473207765726520636C697070656420696E746F20746865697220696E73696465732C20616E6420746563686E696369616E732073746F6F64206279207769746820636F6C6F722D636F64656420656C656374726F6E696320617373656D626C69657320746F207265706C6163652065766572797468696E672074686174207365656D656420646F75627466756C2E205468756D707320616E64207768696E657320736F756E646564207468726F75676820746865207368697020383920736F6D657768657265206166742074686520656E67696E656572696E67206372657720776F726B6564206F6E207468652068756C6C2E01000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008028c3f5c69c21be780e5508d355ebf7d5e060f203ca8717447b71cb44544df5c70200000000000000546865736520776F7264732077657265207574746572656420696E204A756C79203138303520627920416E6E61205061766C6F766E6120536368657265722C20612064697374696E67756973686564206C616479206F662074686520636F7572742C20616E6420636F6E666964656E7469616C206D6169642D6F662D686F6E6F757220746F2074686520456D7072657373204D617279612046796F646F726F766E612E2049742077617320686572206772656574696E6720746F205072696E63652056617373696C792C2061206D616E206869676820696E2072616E6B20616E64206F66666963652C2077686F207761732074686520666972737420746F2061727269766520617401000000000000804bdc1874a3125f1f911fe8c76ac8443a6ec623ef91bc58eabf54c5762097894d0000000000000000",
        ),
        /*po2=*/ 15,
    )?;
    Ok(())
}

#[test]
fn test_keccak_2s() -> Result<()> {
    run_test(
        /*claim=*/
        Digest::from_hex("7719ac59802614d204b9dd6e4baab1d14d35d6a67bb9ea739d53801b0bdb768f")?,
        from_hex(
"0600000000000000436F6D6D616E64657220526F64657269636B20426C61696E65206C6F6F6B6564206672616E746963616C6C792061726F756E6420746865206272696467652E20776865726520686973206F66666963657273207765726520646972656374696E6720726570616972732077697468206C6F7720616E6420757267656E7420766F696365732C2073757267656F6E7320617373697374696E67206174206120646966666963756C74206F7065726174696F6E2E20546865206772617920737465656C20636F6D706172746D656E7420776173206120636F6E667573696F6E206F6620616374697669746965732C2065616368206F726465726C7920627920697473656C662062757420746865206F766572616C6C20696D7072657373696F6E20776173206F66206368616F732E2053637265656E732061626F7665206F6E652068656C6D736D616E27732073746174696F6E2073686F7765642074686520706C616E65742062656C6F7720616E6420746865206F746865722C20736869707320696E206F72626974206E656172204D61634172746875722C20627574206576657279776865726520656C7365207468652070616E656C20636F7665727320686164206265656E2072656D6F7665642066726F6D20636F6E736F6C65732C207465737420696E737472756D656E7473207765726520636C697070656420696E746F20746865697220696E73696465732C20616E6420746563686E696369616E732073746F6F64206279207769746820636F6C6F722D636F64656420656C656374726F6E696320617373656D626C69657320746F207265706C6163652065766572797468696E672074686174207365656D656420646F75627466756C2E205468756D707320616E64207768696E657320736F756E646564207468726F75676820746865207368697020383920736F6D657768657265206166742074686520656E67696E656572696E67206372657720776F726B6564206F6E207468652068756C6C2E0600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000805db9add409333e7f0834569e8e0f6825d684a88363d398b1d0ead06e01d03c1e0200000000000000546865736520776F7264732077657265207574746572656420696E204A756C79203138303520627920416E6E61205061766C6F766E6120536368657265722C20612064697374696E67756973686564206C616479206F662074686520636F7572742C20616E6420636F6E666964656E7469616C206D6169642D6F662D686F6E6F757220746F2074686520456D7072657373204D617279612046796F646F726F766E612E2049742077617320686572206772656574696E6720746F205072696E63652056617373696C792C2061206D616E206869676820696E2072616E6B20616E64206F66666963652C2077686F207761732074686520666972737420746F20617272697665206174060000000000008076d8ddb3fc6c9825ed4a81157c3486e4f35df5cdcf93df3b5c80f1d93ec144fb0000000000000000",
        ),
        /*po2=*/ 15,
    )?;
    Ok(())
}
