// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProveInfo {
    #[prost(message, optional, tag = "1")]
    pub receipt: ::core::option::Option<Receipt>,
    #[prost(message, optional, tag = "2")]
    pub stats: ::core::option::Option<SessionStats>,
    #[prost(message, optional, tag = "3")]
    pub work_receipt: ::core::option::Option<InnerReceipt>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EcallMetric {
    #[prost(uint64, tag = "1")]
    pub count: u64,
    #[prost(uint64, tag = "2")]
    pub cycles: u64,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EcallMetrics {
    #[prost(message, optional, tag = "1")]
    pub bigint: ::core::option::Option<EcallMetric>,
    #[prost(message, optional, tag = "2")]
    pub poseidon2: ::core::option::Option<EcallMetric>,
    #[prost(message, optional, tag = "3")]
    pub read: ::core::option::Option<EcallMetric>,
    #[prost(message, optional, tag = "4")]
    pub sha2: ::core::option::Option<EcallMetric>,
    #[prost(message, optional, tag = "5")]
    pub terminate: ::core::option::Option<EcallMetric>,
    #[prost(message, optional, tag = "6")]
    pub user: ::core::option::Option<EcallMetric>,
    #[prost(message, optional, tag = "7")]
    pub write: ::core::option::Option<EcallMetric>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SyscallMetric {
    #[prost(uint64, tag = "1")]
    pub count: u64,
    #[prost(uint64, tag = "2")]
    pub size: u64,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SyscallMetrics {
    #[prost(message, optional, tag = "1")]
    pub keccak: ::core::option::Option<SyscallMetric>,
    #[prost(message, optional, tag = "2")]
    pub prove_keccak: ::core::option::Option<SyscallMetric>,
    #[prost(message, optional, tag = "3")]
    pub read: ::core::option::Option<SyscallMetric>,
    #[prost(message, optional, tag = "4")]
    pub verify_integrity: ::core::option::Option<SyscallMetric>,
    #[prost(message, optional, tag = "5")]
    pub verify_integrity2: ::core::option::Option<SyscallMetric>,
    #[prost(message, optional, tag = "6")]
    pub write: ::core::option::Option<SyscallMetric>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Duration {
    #[prost(uint64, tag = "1")]
    pub secs: u64,
    #[prost(uint32, tag = "2")]
    pub nanos: u32,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SessionStats {
    #[prost(uint64, tag = "1")]
    pub segments: u64,
    #[prost(uint64, tag = "2")]
    pub total_cycles: u64,
    #[prost(uint64, tag = "3")]
    pub user_cycles: u64,
    #[prost(uint64, tag = "4")]
    pub paging_cycles: u64,
    #[prost(uint64, tag = "5")]
    pub reserved_cycles: u64,
    #[prost(message, optional, tag = "6")]
    pub ecall_metrics: ::core::option::Option<EcallMetrics>,
    #[prost(message, optional, tag = "7")]
    pub syscall_metrics: ::core::option::Option<SyscallMetrics>,
    #[prost(message, optional, tag = "8")]
    pub execution_time: ::core::option::Option<Duration>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Receipt {
    #[prost(message, optional, tag = "1")]
    pub version: ::core::option::Option<super::base::CompatVersion>,
    #[prost(message, optional, tag = "2")]
    pub inner: ::core::option::Option<InnerReceipt>,
    #[prost(bytes = "vec", tag = "3")]
    pub journal: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "4")]
    pub metadata: ::core::option::Option<ReceiptMetadata>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ReceiptMetadata {
    #[prost(message, optional, tag = "1")]
    pub verifier_parameters: ::core::option::Option<super::base::Digest>,
}
/// NOTE: InnerReceipt and InnerAssumptionReceipt are the same type in protobuf.
/// In Rust, they are distinct types because Rust needs to size everything on the
/// stack and e.g. SuccinctReceipt<ReceiptClaim> and SuccinctReceipt<Unknown>
/// have different sizes. Protobuf handles this without issue. GenericReceipt also
/// uses this message type for similar reasons, but the composite kind is unused.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InnerReceipt {
    #[prost(oneof = "inner_receipt::Kind", tags = "1, 2, 3, 4")]
    pub kind: ::core::option::Option<inner_receipt::Kind>,
}
/// Nested message and enum types in `InnerReceipt`.
pub mod inner_receipt {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        #[prost(message, tag = "1")]
        Composite(super::CompositeReceipt),
        #[prost(message, tag = "2")]
        Succinct(super::SuccinctReceipt),
        #[prost(message, tag = "3")]
        Fake(super::FakeReceipt),
        #[prost(message, tag = "4")]
        Groth16(super::Groth16Receipt),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompositeReceipt {
    #[prost(message, repeated, tag = "1")]
    pub segments: ::prost::alloc::vec::Vec<SegmentReceipt>,
    #[prost(message, repeated, tag = "2")]
    pub assumption_receipts: ::prost::alloc::vec::Vec<InnerReceipt>,
    #[prost(message, optional, tag = "3")]
    pub verifier_parameters: ::core::option::Option<super::base::Digest>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SegmentReceipt {
    #[prost(message, optional, tag = "1")]
    pub version: ::core::option::Option<super::base::CompatVersion>,
    #[prost(bytes = "vec", tag = "2")]
    pub seal: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint32, tag = "3")]
    pub index: u32,
    #[prost(string, tag = "4")]
    pub hashfn: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub claim: ::core::option::Option<ReceiptClaim>,
    #[prost(message, optional, tag = "6")]
    pub verifier_parameters: ::core::option::Option<super::base::Digest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuccinctReceipt {
    #[prost(message, optional, tag = "1")]
    pub version: ::core::option::Option<super::base::CompatVersion>,
    #[prost(bytes = "vec", tag = "2")]
    pub seal: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "3")]
    pub control_id: ::core::option::Option<super::base::Digest>,
    /// MaybePruned<Claim>
    #[prost(message, optional, tag = "4")]
    pub claim: ::core::option::Option<MaybePruned>,
    #[prost(message, optional, tag = "5")]
    pub control_inclusion_proof: ::core::option::Option<MerkleProof>,
    #[prost(string, tag = "6")]
    pub hashfn: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "7")]
    pub verifier_parameters: ::core::option::Option<super::base::Digest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MerkleProof {
    #[prost(uint32, tag = "1")]
    pub index: u32,
    #[prost(message, repeated, tag = "2")]
    pub digests: ::prost::alloc::vec::Vec<super::base::Digest>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Groth16Receipt {
    #[prost(message, optional, tag = "1")]
    pub version: ::core::option::Option<super::base::CompatVersion>,
    #[prost(bytes = "vec", tag = "2")]
    pub seal: ::prost::alloc::vec::Vec<u8>,
    /// MaybePruned<Claim>
    #[prost(message, optional, tag = "3")]
    pub claim: ::core::option::Option<MaybePruned>,
    #[prost(message, optional, tag = "4")]
    pub verifier_parameters: ::core::option::Option<super::base::Digest>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ReceiptClaim {
    /// MaybePruned<SystemState>
    #[prost(message, optional, tag = "1")]
    pub pre: ::core::option::Option<MaybePruned>,
    /// MaybePruned<SystemState>
    #[prost(message, optional, tag = "2")]
    pub post: ::core::option::Option<MaybePruned>,
    #[prost(message, optional, tag = "3")]
    pub exit_code: ::core::option::Option<super::base::ExitCode>,
    /// Option<MaybePruned<Input>>
    #[prost(message, optional, tag = "4")]
    pub input: ::core::option::Option<MaybePruned>,
    /// Option<MaybePruned<Output>>
    #[prost(message, optional, tag = "5")]
    pub output: ::core::option::Option<MaybePruned>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Work {
    #[prost(bytes = "vec", tag = "1")]
    pub nonce_min: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub nonce_max: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag = "3")]
    pub value: u64,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct WorkClaim {
    /// MaybePruned<Claim>
    #[prost(message, optional, tag = "1")]
    pub claim: ::core::option::Option<MaybePruned>,
    /// MaybePruned<Work>
    #[prost(message, optional, tag = "2")]
    pub work: ::core::option::Option<MaybePruned>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UnionClaim {
    #[prost(message, optional, tag = "1")]
    pub left: ::core::option::Option<super::base::Digest>,
    #[prost(message, optional, tag = "2")]
    pub right: ::core::option::Option<super::base::Digest>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MaybePruned {
    #[prost(oneof = "maybe_pruned::Kind", tags = "1, 2")]
    pub kind: ::core::option::Option<maybe_pruned::Kind>,
}
/// Nested message and enum types in `MaybePruned`.
pub mod maybe_pruned {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Kind {
        /// Protobuf encoded bytes of the inner value.
        #[prost(bytes, tag = "1")]
        Value(::prost::alloc::vec::Vec<u8>),
        #[prost(message, tag = "2")]
        Pruned(super::super::base::Digest),
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SystemState {
    #[prost(uint32, tag = "1")]
    pub pc: u32,
    #[prost(message, optional, tag = "2")]
    pub merkle_root: ::core::option::Option<super::base::Digest>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Input {}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Output {
    /// MaybePruned<bytes>
    #[prost(message, optional, tag = "1")]
    pub journal: ::core::option::Option<MaybePruned>,
    /// MaybePruned<Assumptions>
    #[prost(message, optional, tag = "2")]
    pub assumptions: ::core::option::Option<MaybePruned>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Assumption {
    #[prost(message, optional, tag = "1")]
    pub claim: ::core::option::Option<super::base::Digest>,
    #[prost(message, optional, tag = "2")]
    pub control_root: ::core::option::Option<super::base::Digest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Assumptions {
    /// MaybePruned<Assumption>
    #[prost(message, repeated, tag = "1")]
    pub inner: ::prost::alloc::vec::Vec<MaybePruned>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FakeReceipt {
    /// MaybePruned<Claim>
    #[prost(message, optional, tag = "1")]
    pub claim: ::core::option::Option<MaybePruned>,
}
