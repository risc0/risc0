// Copyright 2026 RISC Zero, Inc.
//
// Licensed under the Apache License, Version 2.0, <LICENSE-APACHE or
// http://apache.org/licenses/LICENSE-2.0> or the MIT license <LICENSE-MIT or
// http://opensource.org/licenses/MIT>, at your option. This file may not be
// copied, modified, or distributed except according to those terms.
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: Apache-2.0 OR MIT

use std::{
    cell::RefCell,
    io::Read,
    ops::{Deref, DerefMut},
    rc::Rc,
    sync::{
        Arc,
        mpsc::{self, Receiver, SyncSender},
    },
    thread::{self, Scope},
    time::{Duration, Instant},
};

use anyhow::{Context as _, Result, anyhow, bail, ensure};
use risc0_binfmt::{
    AbiKind, ByteAddr, ExitCode, MemoryImage, Program, ProgramBinary, ProgramBinaryHeader,
    SystemState,
};
use risc0_circuit_rv32im::execute::{
    DEFAULT_SEGMENT_LIMIT_PO2, ExecutionError, ExecutionLimit, Executor, PAGE_BYTES, RowLimit,
    SegmentUpdate, Syscall as CircuitSyscall, SyscallContext as CircuitSyscallContext,
};
use risc0_core::scope;
use risc0_zkp::core::digest::Digest;
use risc0_zkvm_platform::fileno;
use tempfile::tempdir;
use tracing::Level;

use crate::{
    Assumptions, ExecutorEnv, FileSegmentRef, MaybePruned, NullSegmentRef, Output, Segment,
    SegmentRef,
    claim::{merge::Merge, receipt::exit_code_from_terminate_state},
    host::{client::env::SegmentPath, server::session::Session},
};

use super::{
    Journal,
    profiler::{self, Profiler},
    syscall::{SyscallContext, SyscallTable},
};

/// The Executor provides an implementation for the execution phase.
///
/// The proving phase uses an execution trace generated by the Executor.
pub struct ExecutorImpl<'a> {
    journal: Journal,
    pub(crate) inner: Executor<'a, CircuitSyscallTable<'a>>,
    pub(crate) env: ExecutorEnv<'a>,
    pub(crate) elf: Option<Vec<u8>>,
    image: MemoryImage,
    profiler: Option<Rc<RefCell<Profiler>>>,
    execution_time: Duration,
}

/// Maximum journal size, imposed to limit the ability of the amount of allocation that a guest
/// program can induce. Can be overridden by the execute caller by providing a custom
/// [`Write`][std::io::Write] stream for the journal in the [`ExecutorEnv`].
const MAX_JOURNAL_SIZE: usize = 100 << 20; // 100 MB

/// Check to see if the executor is compatible with the given guest program.
fn check_program_version(header: &ProgramBinaryHeader) -> Result<()> {
    let abi_kind = header.abi_kind;
    let abi_version = &header.abi_version;

    if abi_kind != AbiKind::V1Compat {
        bail!("ProgramBinary abi_kind mismatch {abi_kind:?} != AbiKind::V1Compat");
    }
    if !semver::VersionReq::parse("^1.0.0")
        .unwrap()
        .matches(abi_version)
    {
        bail!("ProgramBinary abi_version mismatch {abi_version} doesn't match ^1.0.0");
    }

    Ok(())
}

pub(crate) fn circuit_version() -> u32 {
    risc0_circuit_rv32im::execute::RV32IM_M3_CIRCUIT_VERSION
}

/// Maximum number of segments we can queue up before we block execution
const MAX_OUTSTANDING_SEGMENTS: usize = 5;

struct SegmentUpdateProcessor {
    /// Channel used to send SegmentUpdates from the execution thread.
    update_channel: SyncSender<(SegmentUpdate, bool)>,
    /// Channel used to send the final segment output from the execution thread.
    output_channel: SyncSender<MaybePruned<Option<Output>>>,
    /// Channel used to send the segment refs, from the callback, to the execution thread.
    segment_ref_channel: Receiver<Box<dyn SegmentRef>>,
    /// Channel used to send the pre-image digest to the execution thread.
    pre_image_digest_channel: Receiver<Digest>,
}

impl SegmentUpdateProcessor {
    fn spawn<'scope, F>(
        scope: &'scope Scope<'scope, '_>,
        initial_image: &MemoryImage,
        mut segment_callback: F,
    ) -> Self
    where
        F: FnMut(Segment) -> Result<Box<dyn SegmentRef>> + Send + 'scope,
    {
        let mut image = initial_image.clone();
        let (update_send, update_recv) =
            mpsc::sync_channel::<(SegmentUpdate, bool)>(MAX_OUTSTANDING_SEGMENTS);
        let (output_send, output_recv) = mpsc::sync_channel(1);
        let (segment_ref_send, segment_ref_recv) = mpsc::channel();
        let (pre_image_digest_send, pre_image_digest_recv) = mpsc::channel();

        // Spawn the thread that will receive segment updates and construct segments.
        scope.spawn(move || -> Result<()> {
            // Send the pre image digest. If the receiver has already hung up, continue.
            pre_image_digest_send.send(image.image_id()).ok();

            for (update, is_error) in update_recv {
                // Update the current memory image and produce a risc0_circuit_rv32im::Segment.
                let circuit_segment = update
                    .apply_into_segment(&mut image)
                    .context("Failed to apply segment update to memory image")?;

                // If an error is indicated by the executor, and RISC0_DUMP_PATH is set serialize
                // the final segment and write it to the given path.
                if is_error {
                    if let Some(dump_path) = std::env::var_os("RISC0_DUMP_PATH") {
                        tracing::error!(
                            "Execution failure, saving segment to {}:",
                            dump_path.to_string_lossy()
                        );
                        tracing::error!("{circuit_segment:?}");

                        let bytes = circuit_segment.encode()?;
                        tracing::error!("Serialized segment into {} bytes", bytes.len());

                        std::fs::write(dump_path, bytes)?;
                    }
                    break;
                }

                // Add the Output to the Segment. If the output is not none (only true for the
                // final segment), wait to receive the Output constructed by the execution thread
                // and merge it into this segment.
                let mut output =
                    MaybePruned::Pruned(circuit_segment.output_digest.unwrap_or(Digest::ZERO));
                if output.is_some() {
                    output
                        .merge_with(
                            &output_recv.recv().context(
                                "Failed to receipt session output from execution thread",
                            )?,
                        )
                        .context("Failed to merge received session output into segment")?;
                }

                let segment = Segment {
                    index: circuit_segment.index.try_into().unwrap(),
                    output,
                    inner: circuit_segment,
                };
                let segment_ref =
                    segment_callback(segment).context("Segment callback returned an error")?;

                segment_ref_send
                    .send(segment_ref)
                    .map_err(|err| anyhow!("Failed to send segment ref: {err:?}"))?;

                // Update the digests in the working image. This ensures that all digests are
                // populated in the produced Segment and the receiver does not need to hash.
                image.update_digests();
            }
            Ok(())
        });

        SegmentUpdateProcessor {
            update_channel: update_send,
            output_channel: output_send,
            pre_image_digest_channel: pre_image_digest_recv,
            segment_ref_channel: segment_ref_recv,
        }
    }

    fn on_segment_update(&self, update: SegmentUpdate) -> Result<()> {
        self.update_channel
            .send((update, false))
            .context("Failed to send segment update to hasher thread")
    }

    fn on_execution_error(&self, error: &ExecutionError) {
        // If the error is carrying a segment update, send it to the hasher thread to construct a
        // Segment and dump it to a file when RISC0_DUMP_PATH env var is set.
        if let ExecutionError::ExecutionFailed { update, .. } = error
            && let Some(update) = update
        {
            self.update_channel.send((*update.clone(), true)).unwrap_or_else(
                    |err| tracing::error!(%err, "Failed to send segment error update to hasher thread"),
                );
        }
    }
}

impl<'a> ExecutorImpl<'a> {
    /// Construct a new [ExecutorImpl] from a [MemoryImage] and entry point.
    ///
    /// Before a guest program is proven, the [ExecutorImpl] is responsible for
    /// deciding where a zkVM program should be split into [Segment]s and what
    /// work will be done in each segment. This is the execution phase:
    /// the guest program is executed to determine how its proof should be
    /// divided into subparts.
    pub fn new(env: ExecutorEnv<'a>, image: MemoryImage) -> Result<Self> {
        Self::with_details(env, None, image, None)
    }

    /// Construct a new [ExecutorImpl] from the ELF binary of the guest program
    /// you want to run and an [ExecutorEnv] containing relevant
    /// environmental configuration details.
    pub fn from_elf(mut env: ExecutorEnv<'a>, elf: &[u8]) -> Result<Self> {
        let binary = ProgramBinary::decode(elf)?;
        check_program_version(&binary.header)?;

        let image = binary.to_image()?;

        let profiler = if env.pprof_out.is_some() {
            let profiler = Rc::new(RefCell::new(Profiler::new(
                &binary,
                None,
                profiler::read_enable_inline_functions_env_var(),
            )?));
            env.trace.push(profiler.clone());
            Some(profiler)
        } else {
            None
        };

        Self::with_details(env, Some(binary.user_elf), image, profiler)
    }

    /// Construct an [ExecutorImpl] from a kernel ELF.
    ///
    /// This is an internal helper used for kernel-level execution paths.
    #[allow(dead_code)]
    pub(crate) fn from_kernel_elf(env: ExecutorEnv<'a>, elf: &[u8]) -> Result<Self> {
        let kernel = Program::load_elf(elf, u32::MAX)?;
        let image = MemoryImage::new_kernel(kernel);
        Self::with_details(env, Some(elf), image, None)
    }

    fn with_details(
        env: ExecutorEnv<'a>,
        elf: Option<&[u8]>,
        image: MemoryImage,
        profiler: Option<Rc<RefCell<Profiler>>>,
    ) -> Result<Self> {
        // Create a journal and insert it into the env. As the executor runs, the journal data will
        // be written to this buffer and can be retrieved at the end of execution.
        // NOTE: This will overwrite any writer the caller specifies for the journal fd.
        let journal = Journal::default();
        env.posix_io
            .borrow_mut()
            .with_write_fd(fileno::JOURNAL, journal.limit_writer(MAX_JOURNAL_SIZE));

        let syscall_table = SyscallTable::from_env(&env).into();
        let exec = Executor::new(
            image.clone(),
            syscall_table,
            env.input_digest,
            env.trace.clone(),
            env.povw_job_id,
            circuit_version(),
        );
        Ok(Self {
            inner: exec,
            env,
            journal,
            elf: elf.map(|e| e.to_owned()),
            image,
            profiler,
            execution_time: Duration::from_secs(0),
        })
    }

    /// This will run the executor to get a [Session] which contain the results
    /// of the execution.
    pub fn run(&mut self) -> Result<Session> {
        if self.env.segment_path.is_none() {
            self.env.segment_path = Some(SegmentPath::TempDir(Arc::new(tempdir()?)));
        }

        let path = self.env.segment_path.clone().unwrap();
        self.run_with_callback(|segment| Ok(Box::new(FileSegmentRef::new(&segment, &path)?)))
    }

    /// This will run the executor with a gdb server so gdb can be attached.
    pub fn run_with_debugger(&mut self) -> Result<()> {
        let debugger = super::gdb::GdbExecutor::new(self)?;
        eprintln!(
            "connect gdb by running `riscv32im-gdb -ex \"target remote {}\" {}`",
            debugger.local_addr()?,
            debugger.elf_path().display()
        );

        debugger.run()
    }

    /// Run the executor until [crate::ExitCode::Halted] or
    /// [crate::ExitCode::Paused] is reached, producing a [Session] as a result.
    pub fn run_with_callback<F>(&mut self, callback: F) -> Result<Session>
    where
        F: FnMut(Segment) -> Result<Box<dyn SegmentRef>> + Send,
    {
        thread::scope(|scope| {
            let update_processor = SegmentUpdateProcessor::spawn(scope, &self.image, callback);
            while let Some(update) = self
                .run_segment()
                .inspect_err(|err| update_processor.on_execution_error(err))?
            {
                update_processor.on_segment_update(update)?;
            }
            // Send the constructed Output to merge into the final segment.
            update_processor
                .output_channel
                .send(self.final_segment_output(self.segment_limit_po2())?)
                .context("Failed to send output to segment update processor")?;
            drop(update_processor.output_channel);

            // Close the update channel to indicate to the sidecar thread execution has finished.
            drop(update_processor.update_channel);

            // Get the pre_image_digest and the segments from the update_processor.
            // pre_image_digest is only received to avoid recomputation.
            let pre_image_digest = update_processor.pre_image_digest_channel.recv().ok();
            let segments = Some(update_processor.segment_ref_channel.iter().collect());
            self.finalize_session_with(pre_image_digest, segments)
        })
    }

    pub(crate) fn run_segment(&mut self) -> Result<Option<SegmentUpdate>, ExecutionError> {
        scope!("execute");

        // Run the segment.
        let start = Instant::now();
        let update = self.inner.run_segment(self.execution_limit())?;

        // If an update was produced, increment the running total of the execution time.
        self.execution_time += if update.is_some() {
            start.elapsed()
        } else {
            Default::default()
        };

        Ok(update)
    }

    /// Takes the results from the [ExecutorImpl] and creates a [Session], resetting the executor
    /// such that running it will resume execution from the final state.
    ///
    /// The [Session] returned by this function will have only [NullSegmentRef] for segments.
    pub(crate) fn finalize_session(&mut self) -> Result<Session> {
        self.finalize_session_with(None, None)
    }

    /// Internal version of `finalize_session` used with run_with_callback`, which provides the
    /// pre_image_digest and segment refs, constructed by the sidecar thread, as arguments.
    fn finalize_session_with(
        &mut self,
        pre_image_digest: Option<Digest>,
        segments: Option<Vec<Box<dyn SegmentRef>>>,
    ) -> Result<Session> {
        let exec_result = self.inner.state(self.segment_limit_po2());

        tracing::debug!("output_digest: {:?}", exec_result.output);

        let exit_code = exit_code_from_terminate_state(&exec_result.terminate_state)?;

        // Set the session_journal to the committed data iff the guest set a non-zero output.
        let session_journal = exec_result.output.and_then(|digest| {
            (digest != Digest::ZERO).then(|| std::mem::take(&mut *self.journal.buf.lock().unwrap()))
        });
        if !exit_code.expects_output()
            && let Some(ref session_journal) = session_journal
        {
            tracing::debug!(
                "dropping non-empty journal due to exit code {exit_code:?}: 0x{}",
                hex::encode(session_journal)
            );
        };

        // Take (clear out) the list of accessed assumptions.
        // Leave the assumptions cache so it can be used if execution is resumed from pause.
        let syscall_table = self.inner.syscall_handler();
        let assumptions =
            std::mem::take(&mut *syscall_table.inner.assumptions_used.lock().unwrap());
        let mmr_assumptions = syscall_table.inner.mmr_assumptions.take();
        let pending_keccaks = syscall_table.inner.pending_keccaks.take();

        if let Some(profiler) = self.profiler.take() {
            let report = profiler.borrow_mut().finalize_to_vec();
            std::fs::write(self.env.pprof_out.as_ref().unwrap(), report)?;
        }

        // Compute the pre and post state image IDs. When a pre_image_digest is given as an
        // argument, use that value. Otherwise compute it.
        let mut pre_image = exec_result.pre_image;
        let mut post_image = exec_result.post_image;
        let pre_image_digest = pre_image_digest.unwrap_or_else(|| pre_image.image_id());

        // NOTE: When a segment ends in a Halted(_) state, the post_digest will be null.
        let post_digest = match exit_code {
            ExitCode::Halted(_) => Digest::ZERO,
            // NOTE: Computing the memory image digest here might take ~200 ms. It is not done
            // earlier, because this is not common for an execution to end with non-zero exit code.
            _ => post_image.image_id(),
        };

        let syscall_metrics = syscall_table.inner.metrics.borrow().clone();

        // NOTE: Session requires this field to be filled with something. If not provided as an
        // argument, fill it in with NullSegmentRef.
        let segments = segments.unwrap_or_else(|| {
            (0..exec_result.segments)
                .map(|_| -> Box<dyn SegmentRef> { Box::new(NullSegmentRef) })
                .collect()
        });

        let session = Session {
            segments,
            input: self.env.input_digest.unwrap_or_default(),
            journal: session_journal.map(crate::Journal::new),
            exit_code,
            assumptions,
            mmr_assumptions,
            row_count: exec_result.row_count,
            padding_row_count: exec_result.padding_row_count,
            insn_count: exec_result.insn_count,
            pre_state: SystemState {
                pc: 0,
                merkle_root: pre_image_digest,
            },
            post_state: SystemState {
                pc: 0,
                merkle_root: post_digest,
            },
            pending_keccaks,
            syscall_metrics,
            hooks: vec![],
            ecall_metrics: exec_result.ecall_metrics,
            povw_job_id: self.env.povw_job_id,
            execution_time: self.execution_time,
            block_counts: exec_result.block_counts,
        };

        // Reset the executor, into a state where calling `run` will resume execution from the
        // final state of this execution (i.e. resuming from a pause).
        *self = Self::with_details(
            std::mem::take(&mut self.env),
            self.elf.take().as_deref(),
            post_image,
            self.profiler.take(),
        )
        .context("Failed to reset executor")?;

        Ok(session)
    }

    /// Constructs the expected value for the final segment output. This includes the full journal
    /// and assumptions.
    fn final_segment_output(&self, po2: u32) -> Result<MaybePruned<Option<Output>>> {
        let state = self.inner.state(po2);
        ensure!(
            state.terminate_state.is_some(),
            "Cannot compute final segment output for executor that has not terminated"
        );
        let output_digest = state.output.unwrap_or(Digest::ZERO);
        if output_digest == Digest::ZERO {
            return Ok(None.into());
        }
        let journal = self.journal.buf.lock().unwrap().clone();
        Ok(Some(Output {
            journal: journal.into(),
            assumptions: Assumptions(
                self.inner
                    .syscall_handler()
                    .assumptions_used
                    .lock()
                    .unwrap()
                    .iter()
                    .map(|(a, _)| a.clone().into())
                    .collect::<Vec<_>>(),
            )
            .into(),
        })
        .into())
    }

    fn segment_limit_po2(&self) -> u32 {
        self.env
            .segment_limit_po2
            .unwrap_or(DEFAULT_SEGMENT_LIMIT_PO2 as u32)
    }

    fn execution_limit(&self) -> ExecutionLimit {
        let segment_limit_po2 = self.segment_limit_po2() as usize;

        let session_limit = match self.env.session_limit {
            Some(limit) => RowLimit::Hard(limit),
            None => RowLimit::None,
        };

        ExecutionLimit::default()
            .with_segment_po2(segment_limit_po2)
            .with_session_limit(session_limit)
    }
}

struct ContextAdapter<'a, 'b, C> {
    ctx: &'b mut C,
    syscall_table: SyscallTable<'a>,
}

impl<C> ContextAdapter<'_, '_, C>
where
    C: CircuitSyscallContext,
{
    fn peek_string(&mut self, mut addr: ByteAddr) -> Result<String> {
        tracing::trace!("peek_string: {addr:?}");
        let mut buf = Vec::new();
        loop {
            let bytes = self.ctx.peek_u8(addr)?;
            if bytes == 0 {
                break;
            }
            buf.push(bytes);
            addr += 1u32;
        }
        Ok(String::from_utf8(buf)?)
    }
}

impl<'a, C> SyscallContext<'a> for ContextAdapter<'a, '_, C>
where
    C: CircuitSyscallContext,
{
    fn get_pc(&self) -> u32 {
        self.ctx.get_pc()
    }

    fn get_rows(&self) -> u64 {
        self.ctx.get_rows()
    }

    fn load_register(&mut self, idx: usize) -> u32 {
        self.ctx.peek_register(idx).unwrap()
    }

    fn load_page(&mut self, page_idx: u32) -> Result<&[u8; PAGE_BYTES]> {
        self.ctx.peek_page(page_idx)
    }

    fn load_region(&mut self, addr: ByteAddr, size: u32) -> Result<Vec<u8>> {
        self.ctx.peek_region(addr, size as usize)
    }

    fn read_region<'b>(&'b mut self, addr: ByteAddr, size: u32) -> Result<Box<dyn Read + 'b>> {
        Ok(Box::new(self.ctx.read_region(addr, size as usize)?))
    }

    fn load_u8(&mut self, addr: ByteAddr) -> Result<u8> {
        self.ctx.peek_u8(addr)
    }

    fn load_u32(&mut self, addr: ByteAddr) -> Result<u32> {
        self.ctx.peek_u32(addr)
    }

    fn syscall_table(&self) -> &SyscallTable<'a> {
        &self.syscall_table
    }
}

#[derive(Clone)]
pub(crate) struct CircuitSyscallTable<'a> {
    inner: SyscallTable<'a>,
}

impl<'a> Deref for CircuitSyscallTable<'a> {
    type Target = SyscallTable<'a>;

    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

impl<'a> DerefMut for CircuitSyscallTable<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}

impl CircuitSyscall for CircuitSyscallTable<'_> {
    fn host_read(
        &self,
        ctx: &mut impl CircuitSyscallContext,
        fd: u32,
        buf: &mut [u8],
    ) -> Result<u32> {
        let mut ctx = ContextAdapter {
            ctx,
            syscall_table: self.inner.clone(),
        };

        let name_ptr = ByteAddr(fd);
        let syscall = ctx.peek_string(name_ptr)?;
        tracing::trace!("host_read({syscall}, into_guest: {})", buf.len());

        let ret = self
            .inner
            .get_syscall(&syscall)
            .context(format!("Unknown syscall: {syscall:?}"))?
            .borrow_mut()
            .syscall(&syscall, &mut ctx, buf)?;
        ret.try_into()
            .map_err(|e| anyhow!("invalid syscall return value: {e}"))
    }

    fn host_write(
        &self,
        _ctx: &mut impl CircuitSyscallContext,
        _fd: u32,
        buf: &[u8],
    ) -> Result<u32> {
        if tracing::enabled!(Level::DEBUG) {
            let str = String::from_utf8(buf.to_vec())?;
            tracing::debug!("R0VM {str}");
        }
        Ok(buf.len() as u32)
    }
}

impl<'a> From<SyscallTable<'a>> for CircuitSyscallTable<'a> {
    fn from(inner: SyscallTable<'a>) -> Self {
        Self { inner }
    }
}
