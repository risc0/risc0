use std::env;
use std::fs;
use std::path::Path;
use std::process::Command;

fn main() {
    println!("cargo:rerun-if-changed=../Contract.sol");
    println!("cargo:rerun-if-changed=build.rs");

    let out_dir = env::var("OUT_DIR").unwrap();
    let contract_path = Path::new("../Contract.sol");
    
    // Check if solc is available
    let solc_check = Command::new("solc")
        .arg("--version")
        .output();
    
    if solc_check.is_err() {
        panic!("solc not found! Please install solc (Solidity compiler)");
    }

    // Compile the contract to get the bytecode
    let output = Command::new("solc")
        .arg("--bin")
        .arg("--optimize")
        .arg(contract_path)
        .output()
        .expect("Failed to execute solc");

    if !output.status.success() {
        panic!("solc compilation failed: {}", String::from_utf8_lossy(&output.stderr));
    }

    let output_str = String::from_utf8_lossy(&output.stdout);
    
    // Parse the output to extract the bytecode
    let lines: Vec<&str> = output_str.lines().collect();
    let mut bytecode = String::new();
    let mut found_binary = false;
    
    for line in lines {
        if line.contains("Binary:") {
            found_binary = true;
            continue;
        }
        if found_binary && !line.is_empty() && !line.starts_with('=') {
            bytecode = line.to_string();
            break;
        }
    }

    if bytecode.is_empty() {
        panic!("Failed to extract bytecode from solc output");
    }

    // Generate Rust code with the bytecode
    let generated_code = format!(
        r#"// Auto-generated bytecode from Contract.sol
pub const CONTRACT_BYTECODE: &str = "{}";
"#,
        bytecode
    );

    let dest_path = Path::new(&out_dir).join("contract_bytecode.rs");
    fs::write(&dest_path, generated_code).expect("Failed to write generated bytecode file");

    println!("cargo:rustc-env=CONTRACT_BYTECODE_PATH={}", dest_path.display());
}