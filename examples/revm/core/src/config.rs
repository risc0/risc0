// Copyright 2024 RISC Zero, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/// EVM bytecode configuration

use serde::{Deserialize, Serialize};

#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct EvmConfig {
    pub bytecode: Vec<u8>,
    pub function_signature: String,
    pub input: i64,
}

impl Default for EvmConfig {
    fn default() -> Self {
        Self {
            // Output of `solc --bin Contract.sol`
            bytecode: hex::decode("6080604052348015600e575f80fd5b5061048b8061001c5f395ff3fe608060405234801561000f575f80fd5b5060043610610029575f3560e01c8063b511c6be1461002d575b5f80fd5b61004760048036038101906100429190610116565b61005d565b604051610054919061015b565b60405180910390f35b5f806106e483605461006f91906101a1565b60028561007c9190610369565b6106e561008991906101a1565b6003866100969190610369565b60546100a291906101a1565b6004876100af9190610369565b6100b991906103d4565b6100c39190610414565b6100cd91906103d4565b6100d79190610414565b149050919050565b5f80fd5b5f819050919050565b6100f5816100e3565b81146100ff575f80fd5b50565b5f81359050610110816100ec565b92915050565b5f6020828403121561012b5761012a6100df565b5b5f61013884828501610102565b91505092915050565b5f8115159050919050565b61015581610141565b82525050565b5f60208201905061016e5f83018461014c565b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f6101ab826100e3565b91506101b6836100e3565b92508282026101c4816100e3565b91507f800000000000000000000000000000000000000000000000000000000000000084145f841216156101fb576101fa610174565b5b82820584148315176102105761020f610174565b5b5092915050565b5f8160011c9050919050565b5f808291508390505b600185111561026c5780860481111561024857610247610174565b5b60018516156102575780820291505b808102905061026585610217565b945061022c565b94509492505050565b5f825f811461028b57600181146102955761029e565b6001915050610355565b82915050610355565b50816102ac575f9050610355565b600190505f8213600181146102c7575f81146102df576102f3565b8286048311156102da576102d9610174565b5b6102f3565b8286058312156102f2576102f1610174565b5b5b506001831615610301578190505b818202915061030f83610217565b925061031d85848484610223565b9250905081850481115f8213161561033857610337610174565b5b81840581125f8212161561034f5761034e610174565b5b81810290505b949350505050565b5f60ff82169050919050565b5f610373826100e3565b915061037e8361035d565b92506103cc7f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f80000000000000000000000000000000000000000000000000000000000000008585610275565b905092915050565b5f6103de826100e3565b91506103e9836100e3565b925082820390508181125f8412168282135f85121516171561040e5761040d610174565b5b92915050565b5f61041e826100e3565b9150610429836100e3565b92508282019050828112155f8312168382125f84121516171561044f5761044e610174565b5b9291505056fea264697066735822122028d4bca65832f0906f09743d610375bece4352629f67d9bc8e6af2a77b139e6264736f6c634300081a0033").unwrap(),
            function_signature: "isSolved(int256)".to_string(),
            input: 42,
        }
    }
}

impl EvmConfig {
    /// Create a new EVM config with custom bytecode
    pub fn new(bytecode_hex: &str, function_signature: &str, input: i64) -> Result<Self, hex::FromHexError> {
        let bytecode = hex::decode(bytecode_hex)?;
        Ok(Self { bytecode, function_signature: function_signature.to_string(), input: input as i64 })
    }
    
    /// Get the bytecode as a reference
    pub fn get_bytecode(&self) -> &[u8] {
        &self.bytecode
    }
    
    /// Get the bytecode as owned Vec
    pub fn get_bytecode_owned(&self) -> Vec<u8> {
        self.bytecode.clone()
    }

    /// Get the function signature
    pub fn get_function_signature(&self) -> &str {
        &self.function_signature
    }

    /// Get the input value
    pub fn get_input(&self) -> i64 {
        self.input
    }
}
